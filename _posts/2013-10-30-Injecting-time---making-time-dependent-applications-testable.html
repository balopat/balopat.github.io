---           
layout: post
title: Injecting time - making time dependent applications testable
date: 2013-10-30 18:03:00 UTC
updated: 2013-12-14 19:44:55 UTC
comments: false
categories: Web/Tech
---

<p> this post was imported and exported at least twice, and hasn't been polished up yet. bear with me, thank you for your patience </p>
 
<p><span style="font-size: 14pt;"><strong>Time dependent applications are all around us</strong></span></p><br /><p>Time dependent logic in our applications is quite natural, some examples could be: </p><br /><ul><br /><li>A BI solution - today&#39;s reports have to contain the data from the days since the last business day&#0160;</li><br /><li>An Enterprise Risk Engine - operational risk depends on the age of an exception</li><br /><li>A Social network software - the current age of a message should be displayed, and messages should be displayed in reverse order</li><br /></ul><br /><p>&#0160;Time to time (pun intended) I see implementations where the business logic explicitly uses SYSDATE() in Oracle, or new Date() in Java/Scala, or <em>date</em> in shell script.<br />These make the system very very hard to test can have insidious bugs and also make people very angry.&#0160;</p><br /><p><span style="font-size: 14pt;"><strong>Bad: Hard coded dependency on the current day/time</strong></span></p><br /><p><span style="text-decoration: underline;">Time and speed dependent, flickering tests</span></p><br /><p>Let me show you an example why hardcoded new Date() can be a problem.</p><br /><script src="https://gist.github.com/balopat/7226715.js"></script><br /><p>&#0160;</p><br /><p>On my machine this test failes 2 times out of 10. THE WORST kind of test is the flickering test! </p><br /><p>So, why is this happening? The time difference between the new Date() in the Spec and the Wall code, is probably nanoseconds, and equality is checking on the level of milliseconds (&quot;The class&#0160;<code>Date</code>&#0160;represents a specific instant in time, with millisecond precision.&quot;). Thus, if we are &quot;lucky&quot; the two Dates will be in the same millisecond, our test passes, but if the Wall code is just after the border of the next millisecond, the test will fail.&#0160;</p><br /><p><span style="text-decoration: underline;">Timezone dependency</span></p><br /><p>Working on a global project I had the pleasure to meet unit tests written on a London machine in a time dependent manner which resulted in a strange situation: all the builds were passing in London (including the build server) but when I moved to New York, I found that on my local machine it&#39;s failing.&#0160;</p><br /><p><span style="text-decoration: underline;">Time dependent feed file processing</span></p><br /><p>I found that whenever batch processing of feed files is dependent on the date, it is virtually impossible to reuse exactly the same feed files from the past, and I had to copy them, rename them to today&#39;s date, even worse if I had to modify the feed files so that the data will be be &quot;up to date&quot; and then run the system.&#0160;</p><br /><p>How easier it would be if I could play time machine and tell the system that I want to run it for a past (or a future!) date? &#0160;</p><br /><p>&#0160;</p><br /><p><span style="font-size: 14pt;"><strong>How do I do it well? Dependency injection!</strong></span></p><br /><p><strong>Version 1: Clock Injection</strong></p><br /><p>Philosophical sidenote (the impatient can safely skip this): Some people say that Time is an actor. Until I know better I find it a bit confusing, especially that Actors act, and time is due to the fact that things are in change, the Earth revolves around the Sun, crystals pulsate and we transform the aggregated sideeffect of these changes with <em>change-to-time converter tools</em> (i.e. clocks!) into the man-made scale we call: time. &#0160;</p><br /><p>I like to think about time as a constantly changing value, which is provided by a service called Clock. If we embrace this and <strong>introduce a Clock as a collaborator</strong>&#0160;then we&#39;ll be able to mock it out, inject stubbed versions, i.e. <strong>have control over time.</strong></p><br /><p>so...</p><br /><script src="https://gist.github.com/balopat/7227154.js"></script><br /><p>After all this, an example to control the time in a mocked Clock would be </p><br /><script src="https://gist.github.com/balopat/7227169.js"></script><br /><p><span style="font-size: 13pt;"><strong>Testing the Real clock itself</strong></span></p><br /><p>Of course, you can&#39;t get away from the problem totally, there is always a part in the system which will have to have hard dependency on time. But similar to any other third party library dependency, you want to contain it, wrap it up, and test it as you can to ensure your wrapper does what it&#39;s supposed to do. </p><br /><p>In our case, this is the RealClock class, which returns new Date() in its getTime() method &#0160;implementation.&#0160;</p><br /><p>A good enough way to test it is to ensure that the returned date is between the time of the commands ran before and after getTime.&#0160;</p><br /><script src="https://gist.github.com/balopat/7227184.js"></script><br /><p><strong><br /></strong></p><br /><p><strong>Version 2: Time Injection</strong></p><br /><p>If injecting the Clock service is too much, or it is just impossible in your case, then there is another way, but that will modify your API: injecting time! </p><br /><p>This would mean modifying the signature of your method (script, stored procedure, report, etc.), which depends on time, for example in our case, the Wall.message function would have another version with another argument called currentTimeStamp. &#0160;</p><br /><p><strong>In Summary </strong></p><br /><ol><br /><li>Avoid hardcoded dependency on new Date(), SYSDATE, CURRENT_TIMESTAMP, etc.</li><br /><li>You can choose between two versions of dependency injection to avoid hardcoded time dependency: &#0160;<ol><br /><li>injecting Clock service (collaborator level injection)</li><br /><li>injecting time (method/script signature level injection)</li><br /></ol></li><br /></ol><br /><br /><br/>